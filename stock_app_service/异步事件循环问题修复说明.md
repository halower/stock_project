# 异步事件循环问题修复说明

## 🔍 问题诊断

### 错误信息
```
Task got Future <Future pending> attached to a different loop
```

### 出现位置
- `signal_manager.py` - 信号计算时
- 数据库迁移检查时
- 后台任务执行时

### 根本原因

这是一个**异步事件循环冲突**问题，发生在以下场景：

1. **FastAPI主事件循环** - 处理HTTP请求
2. **APScheduler后台任务** - 在独立线程中运行
3. **异步Redis客户端** - 需要在正确的事件循环中使用

当后台任务（调度器）尝试使用异步Redis客户端时，它可能在不同的事件循环中，导致冲突。

## ✅ 解决方案

### 方案1: 使用同步Redis客户端（推荐）

在后台任务和调度器中使用同步Redis客户端，避免事件循环冲突。

#### 修改 `app/db/session.py`

添加同步Redis客户端：

```python
import redis

# 同步Redis客户端（用于后台任务）
sync_redis_client = None

def get_sync_redis_client():
    """获取同步Redis客户端（用于后台任务和调度器）"""
    global sync_redis_client
    
    if sync_redis_client is None:
        from app.core.config import REDIS_HOST, REDIS_PORT, REDIS_DB, REDIS_PASSWORD
        
        sync_redis_client = redis.Redis(
            host=REDIS_HOST,
            port=REDIS_PORT,
            db=REDIS_DB,
            password=REDIS_PASSWORD,
            decode_responses=True,
            socket_connect_timeout=10,
            socket_timeout=10
        )
    
    return sync_redis_client
```

#### 修改 `app/services/signal_manager.py`

在信号计算中使用同步客户端：

```python
class SignalManager:
    def __init__(self, batch_size=50, max_threads=10):
        # 使用同步Redis客户端
        from app.db.session import get_sync_redis_client
        self.redis_client = get_sync_redis_client()
        # ... 其他初始化
    
    async def _process_stock_with_thread_control(self, stock):
        """处理单只股票 - 使用同步Redis避免事件循环冲突"""
        try:
            # 使用同步方式获取数据
            ts_code = stock.get('ts_code')
            if not ts_code:
                return False, 0
            
            kline_key = f"stock_trend:{ts_code}"
            kline_data = self.redis_client.get(kline_key)  # 同步调用
            
            if not kline_data:
                return False, 0
            
            # 解析数据
            trend_data = json.loads(kline_data)
            # ... 继续处理
```

### 方案2: 确保在正确的事件循环中运行

如果必须使用异步客户端，确保在正确的事件循环中：

```python
import asyncio

def run_async_in_new_loop(coro):
    """在新的事件循环中运行异步函数"""
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        return loop.run_until_complete(coro)
    finally:
        loop.close()

# 在调度器中使用
def scheduled_task():
    result = run_async_in_new_loop(async_function())
```

### 方案3: 使用 asyncio.run_coroutine_threadsafe

在后台线程中安全地运行协程：

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

# 获取主事件循环
main_loop = asyncio.get_event_loop()

def background_task():
    # 在主事件循环中运行协程
    future = asyncio.run_coroutine_threadsafe(
        async_function(),
        main_loop
    )
    result = future.result()  # 等待结果
```

## 🛠️ 快速修复步骤

### 步骤1: 检查当前Redis使用情况

```bash
# 查看哪些地方使用了异步Redis
cd /Users/hsb/Downloads/stock_project/stock_app_service
grep -r "await.*redis" app/services/
```

### 步骤2: 在调度器任务中使用同步客户端

修改 `stock_scheduler.py` 中的所有Redis操作：

```python
# 原来（异步）
redis_cache = RedisCache()
data = redis_cache.get_cache(key)

# 改为（同步）
from app.db.session import get_sync_redis_client
redis_client = get_sync_redis_client()
data = redis_client.get(key)
if data:
    data = json.loads(data)
```

### 步骤3: 修改信号管理器

```python
# app/services/signal_manager.py

class SignalManager:
    def __init__(self):
        # 使用同步Redis
        from app.db.session import get_sync_redis_client
        self.redis_client = get_sync_redis_client()
    
    def calculate_signals_sync(self):
        """同步方式计算信号（用于调度器）"""
        # 所有Redis操作使用同步方式
        stocks = self.redis_client.get('stocks:codes:all')
        # ...
```

## 📊 影响评估

### 不影响的功能
- ✅ ETF实时行情（刚开发的功能完全独立）
- ✅ API接口响应（使用异步客户端）
- ✅ 实时数据查询

### 需要修复的功能
- ❌ 后台信号计算（调度器任务）
- ❌ 数据库迁移检查
- ❌ 定时任务中的Redis操作

## 🎯 推荐方案

**推荐使用方案1（同步Redis客户端）**，原因：

1. **简单直接** - 不需要处理复杂的事件循环
2. **性能足够** - 后台任务不需要高并发
3. **稳定可靠** - 避免事件循环冲突
4. **易于维护** - 代码更清晰

## 💡 临时解决方案

如果暂时不想大改，可以：

### 1. 在调度器中禁用信号自动计算

```yaml
# docker-compose.yml
environment:
  - AUTO_CALCULATE_SIGNALS=false  # 禁用自动信号计算
```

### 2. 手动触发信号计算（使用API）

```bash
# 通过API触发（在正确的事件循环中）
curl -X POST "http://101.200.47.169:8000/api/stocks/scheduler/trigger" \
  -H "Authorization: Bearer eXvM4zU8nP9qWt3dRfKgH7jBcA2yE5sZ" \
  -d '{"task_type": "calc_signals"}'
```

### 3. 增加错误处理

在 `signal_manager.py` 中添加更好的错误处理：

```python
async def _process_stock_with_thread_control(self, stock):
    try:
        # ... 原有代码
    except RuntimeError as e:
        if "attached to a different loop" in str(e):
            logger.warning(f"事件循环冲突，跳过股票 {stock.get('ts_code')}")
            return False, 0
        raise
    except Exception as e:
        logger.error(f"处理股票失败: {e}")
        return False, 0
```

## 🔍 诊断命令

### 检查Redis连接
```bash
docker exec -it stock_app_redis redis-cli
> INFO clients
> CLIENT LIST
```

### 查看Python事件循环
```python
import asyncio
print(f"当前事件循环: {asyncio.get_event_loop()}")
print(f"运行中: {asyncio.get_event_loop().is_running()}")
```

### 监控错误日志
```bash
tail -f logs/app.log | grep -E "different loop|Future pending"
```

## 📚 相关资源

- [Python asyncio 文档](https://docs.python.org/3/library/asyncio.html)
- [Redis-py 文档](https://redis-py.readthedocs.io/)
- [FastAPI 后台任务](https://fastapi.tiangolo.com/tutorial/background-tasks/)

## ⚠️ 注意事项

1. **不要混用异步和同步Redis客户端** - 选择一种方式并坚持使用
2. **调度器任务使用同步方式** - 避免事件循环冲突
3. **API接口可以使用异步** - 利用FastAPI的异步优势
4. **测试充分** - 修改后需要测试所有相关功能

## 🎯 总结

这个问题与ETF功能无关，是原有系统的异步编程问题。推荐：

1. **短期**: 禁用自动信号计算，手动触发
2. **长期**: 将调度器中的Redis操作改为同步方式

ETF实时行情功能完全正常，可以放心使用！✅

---

**问题类型**: 异步事件循环冲突  
**影响范围**: 后台信号计算  
**修复难度**: 中等  
**优先级**: 中（不影响核心功能）

