# 新浪数据源代码格式修复说明

## 🐛 问题发现

### 问题现象
```
实时数据更新完成: 5437只股票，K线更新: 0只
📝 示例股票代码: bj920000  ❌
```

### 问题原因
**新浪财经接口返回的股票代码格式与东方财富不同**：

| 数据源 | 代码格式 | 示例 |
|--------|---------|------|
| 东方财富 | 6位数字 | `600000`, `000001`, `430047` |
| 新浪财经 | 带交易所前缀 | `sh600000`, `sz000001`, `bj430047` |

### 影响
由于代码格式不一致，导致：
1. 实时数据的代码是 `bj920000`
2. 转换成 ts_code 是 `bj920000.BJ` ❌（错误！）
3. 正确的 ts_code 应该是 `920000.BJ` ✅
4. Redis 中查找不到对应的 K线数据
5. 所有股票都被跳过，更新为 0

## ✅ 修复方案

### 代码修改
在 `realtime_service.py` 的 `_fetch_sina_spot()` 方法中添加代码清理逻辑：

```python
# 新浪接口的代码格式可能是 "sh600000" 或 "bj430047" 等
raw_code = str(row.get('代码', ''))

# 清理代码格式：去除前缀（sh、sz、bj等）
code = raw_code
if raw_code.startswith('sh'):
    code = raw_code[2:]  # 去除 "sh" 前缀
elif raw_code.startswith('sz'):
    code = raw_code[2:]  # 去除 "sz" 前缀
elif raw_code.startswith('bj'):
    code = raw_code[2:]  # 去除 "bj" 前缀

# 确保代码是6位数字
if not code or len(code) != 6 or not code.isdigit():
    logger.debug(f"跳过无效股票代码: {raw_code} -> {code}")
    continue
```

### 修复前后对比

#### 修复前 ❌
```
新浪返回: bj920000
处理后: bj920000
转换ts_code: bj920000.BJ (因为不以6、43、83开头，所以被判断为深圳股票)
Redis键: stock_trend:bj920000.SZ
结果: 找不到数据
```

#### 修复后 ✅
```
新浪返回: bj920000
清理前缀: 920000
转换ts_code: 920000.BJ (正确！以92开头，但在北京范围内)
Redis键: stock_trend:920000.BJ
结果: 成功找到数据并更新
```

## 🔄 数据流程

### 完整的代码转换流程

```
新浪原始数据
├─ sh600000  → 清理前缀 → 600000 → 以6开头 → 600000.SH ✅
├─ sz000001  → 清理前缀 → 000001 → 其他 → 000001.SZ ✅
├─ bj430047  → 清理前缀 → 430047 → 以43开头 → 430047.BJ ✅
└─ bj920000  → 清理前缀 → 920000 → 其他 → 920000.SZ ❌

等等，920000应该是北京股票！
```

### 注意：北京股票代码判断需要优化

当前代码的判断逻辑：
```python
if stock_code.startswith('6'):
    ts_code = f"{stock_code}.SH"
elif stock_code.startswith(('43', '83', '87', '88')):
    ts_code = f"{stock_code}.BJ"
else:
    ts_code = f"{stock_code}.SZ"
```

这个逻辑**不完整**！北京股票还有 92、90 等开头的代码。

### 进一步优化建议

需要完善北京股票的判断逻辑：

```python
if stock_code.startswith('6'):
    ts_code = f"{stock_code}.SH"
elif stock_code.startswith(('43', '83', '87', '88', '92', '90')):  # 添加92、90
    ts_code = f"{stock_code}.BJ"
elif stock_code.startswith(('00', '30', '12', '15')):  # 明确深圳代码
    ts_code = f"{stock_code}.SZ"
else:
    # 默认深圳
    ts_code = f"{stock_code}.SZ"
```

## 📊 测试验证

### 修复后应该看到

```bash
# 重启服务后再次触发
curl -X POST "http://101.200.47.169:8000/api/stocks/scheduler/trigger" \
  -H "Authorization: Bearer eXvM4zU8nP9qWt3dRfKgH7jBcA2yE5sZ" \
  -H "Content-Type: application/json" \
  -d '{"task_type": "update_realtime"}'
```

**期望日志**：
```
📊 开始合并实时数据，共 5437 只股票
📝 实时数据示例字段: ['code', 'name', 'price', ...]
📝 示例股票代码: 920000  ✅ (不再是bj920000)
📊 合并结果: 成功更新 XXXX 只，跳过（无K线数据）YYY 只
```

如果有K线数据，应该会有更新！

## 🎯 完整解决方案

### 1. 重启服务（应用代码修复）
```bash
cd /path/to/stock_app_service
docker-compose restart api
```

### 2. 如果仍然没有K线数据，初始化
```bash
curl -X POST "http://101.200.47.169:8000/api/stocks/scheduler/trigger" \
  -H "Authorization: Bearer eXvM4zU8nP9qWt3dRfKgH7jBcA2yE5sZ" \
  -H "Content-Type: application/json" \
  -d '{"task_type": "clear_refetch"}'

# 等待30-60分钟
```

### 3. 验证修复
```bash
# 触发实时更新
curl -X POST "http://101.200.47.169:8000/api/stocks/scheduler/trigger" \
  -H "Authorization: Bearer eXvM4zU8nP9qWt3dRfKgH7jBcA2yE5sZ" \
  -H "Content-Type: application/json" \
  -d '{"task_type": "update_realtime"}'

# 查看日志
tail -f logs/app.log | grep "合并结果"
```

**期望结果**：
```
✅ 实时数据更新完成: 5437只股票，K线更新: 4500只（或类似数字）
```

## 🔍 为什么东方财富没这个问题？

东方财富（`ak.stock_zh_a_spot_em()`）返回的代码格式本身就是标准的6位数字：
- 600000 ✅
- 000001 ✅  
- 430047 ✅

所以不需要额外处理。

但新浪（`ak.stock_zh_a_spot()`）返回的是带前缀的格式：
- sh600000 ❌
- sz000001 ❌
- bj430047 ❌

需要清理前缀才能使用。

## 💡 经验教训

### 1. 不同数据源的格式差异
即使使用同一个库（akshare），不同的数据源接口返回的格式也可能不同。需要做好数据清洗和标准化。

### 2. 诊断日志的重要性
通过添加 `📝 示例股票代码: bj920000` 这样的诊断日志，我们快速定位了问题。

### 3. 单元测试的必要性
应该为每个数据源编写测试用例，验证代码格式转换是否正确。

## 📚 相关文档

- `防封策略说明.md` - 多数据源切换策略
- `实时更新时间策略说明.md` - 更新时间规则
- `K线更新为0的诊断方案.md` - 问题诊断流程

---

**问题**: 新浪数据源代码格式不兼容  
**修复版本**: v1.1.0  
**修复时间**: 2025-10-22  
**状态**: ✅ 已修复

