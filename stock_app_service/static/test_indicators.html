<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>æŒ‡æ ‡æµ‹è¯• - Volume Profile & Order Blocks</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            font-family: Arial, sans-serif;
            background: #1e1e1e;
            color: #fff;
        }
        #chart-container { 
            width: 100%; 
            height: 600px; 
            border: 1px solid #333;
            position: relative;
            background: #131722;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2e39;
            border-radius: 8px;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #2962FF;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #1e53e5;
        }
        button.danger {
            background: #f23645;
        }
        button.danger:hover {
            background: #d32f2f;
        }
        #log {
            margin-top: 20px;
            padding: 15px;
            background: #2a2e39;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .log-success { color: #4caf50; }
        .log-error { color: #f44336; }
        .log-info { color: #2196f3; }
        .vp-box {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }
        .order-block {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h2>ğŸ“Š æŒ‡æ ‡æ¸²æŸ“æµ‹è¯•</h2>
    
    <div class="controls">
        <button onclick="testVolumeProfile()">æµ‹è¯• Volume Profile</button>
        <button onclick="testOrderBlocks()">æµ‹è¯• Pivot Order Blocks</button>
        <button onclick="testEMA()">æµ‹è¯• EMA çº¿æ¡</button>
        <button class="danger" onclick="clearAll()">æ¸…é™¤æ‰€æœ‰æŒ‡æ ‡</button>
        <button onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
    </div>
    
    <div id="chart-container"></div>
    <div id="log"></div>
    
    <script>
        let chart;
        let vpElements = [];
        let obElements = [];
        let emaSeriesList = [];
        
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const className = 'log-' + type;
            logDiv.innerHTML = `<div class="${className}">[${time}] ${msg}</div>` + logDiv.innerHTML;
            console.log(msg);
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        // åˆ›å»ºå›¾è¡¨
        log('åˆå§‹åŒ–å›¾è¡¨...', 'info');
        const chartContainer = document.getElementById('chart-container');
        const { createChart } = LightweightCharts;
        
        chart = createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: 600,
            layout: {
                background: { color: '#131722' },
                textColor: '#d1d4dc',
            },
            grid: {
                vertLines: { color: '#2B2B43' },
                horzLines: { color: '#2B2B43' },
            },
        });
        
        // æ·»åŠ Kçº¿æ•°æ®
        const candleSeries = chart.addCandlestickSeries({
            upColor: '#26a69a',
            downColor: '#ef5350',
            borderVisible: false,
            wickUpColor: '#26a69a',
            wickDownColor: '#ef5350',
        });
        
        // ç”Ÿæˆæµ‹è¯•æ•°æ®
        const testData = [];
        const basePrice = 100;
        for (let i = 0; i < 100; i++) {
            const date = new Date(2024, 0, i + 1);
            const dateStr = date.getFullYear() + '-' + 
                           String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                           String(date.getDate()).padStart(2, '0');
            const randomChange = (Math.random() - 0.5) * 5;
            const open = basePrice + randomChange;
            const close = open + (Math.random() - 0.5) * 3;
            const high = Math.max(open, close) + Math.random() * 2;
            const low = Math.min(open, close) - Math.random() * 2;
            
            testData.push({
                time: dateStr,
                open: open,
                high: high,
                low: low,
                close: close
            });
        }
        
        candleSeries.setData(testData);
        chart.timeScale().fitContent();
        
        log('âœ… å›¾è¡¨åˆ›å»ºæˆåŠŸï¼ŒKçº¿æ•°æ®: ' + testData.length + ' æ ¹', 'success');
        
        // æµ‹è¯• Volume Profile
        function testVolumeProfile() {
            log('ğŸ”§ å¼€å§‹æµ‹è¯• Volume Profile...', 'info');
            
            // æ¸…é™¤æ—§çš„
            vpElements.forEach(el => el.remove());
            vpElements = [];
            
            // æ¨¡æ‹Ÿ Volume Profile æ•°æ®
            const priceMin = 95;
            const priceMax = 105;
            const numBars = 20;
            const priceStep = (priceMax - priceMin) / numBars;
            
            for (let i = 0; i < numBars; i++) {
                const priceLow = priceMin + i * priceStep;
                const priceHigh = priceLow + priceStep;
                const volume = Math.random() * 1000 + 500;
                const inValueArea = i >= 8 && i <= 12; // ä¸­é—´éƒ¨åˆ†æ˜¯ Value Area
                
                const box = document.createElement('div');
                box.className = 'vp-box';
                box.style.position = 'absolute';
                box.style.pointerEvents = 'none';
                box.style.zIndex = '5';
                
                if (inValueArea) {
                    box.style.backgroundColor = 'rgba(67, 70, 81, 0.5)';
                    box.style.border = '1px solid rgba(67, 70, 81, 0.7)';
                } else {
                    box.style.backgroundColor = 'rgba(251, 192, 45, 0.5)';
                    box.style.border = '1px solid rgba(251, 192, 45, 0.7)';
                }
                
                box.dataset.priceLow = priceLow;
                box.dataset.priceHigh = priceHigh;
                box.dataset.volume = volume;
                
                chartContainer.appendChild(box);
                vpElements.push(box);
            }
            
            log('âœ… åˆ›å»ºäº† ' + numBars + ' ä¸ª Volume Profile æŸ±', 'success');
            
            // æ›´æ–°ä½ç½®
            updateVPPositions();
            
            // ç›‘å¬å›¾è¡¨å˜åŒ–
            chart.timeScale().subscribeVisibleLogicalRangeChange(updateVPPositions);
        }
        
        function updateVPPositions() {
            try {
                const timeScale = chart.timeScale();
                const visibleRange = timeScale.getVisibleLogicalRange();
                
                if (!visibleRange) return;
                
                const rightX = timeScale.logicalToCoordinate(visibleRange.to);
                const chartHeight = chartContainer.clientHeight;
                const priceRange = chart.priceScale('right').getVisiblePriceRange();
                
                if (!priceRange) return;
                
                const priceMin = priceRange.from;
                const priceMax = priceRange.to;
                const priceSpan = priceMax - priceMin;
                
                const maxVolume = Math.max(...vpElements.map(el => parseFloat(el.dataset.volume)));
                const maxWidth = 150;
                
                vpElements.forEach(box => {
                    const priceLow = parseFloat(box.dataset.priceLow);
                    const priceHigh = parseFloat(box.dataset.priceHigh);
                    const volume = parseFloat(box.dataset.volume);
                    
                    const y1 = chartHeight * (1 - (priceHigh - priceMin) / priceSpan);
                    const y2 = chartHeight * (1 - (priceLow - priceMin) / priceSpan);
                    const width = (volume / maxVolume) * maxWidth;
                    
                    if (rightX !== null && !isNaN(y1) && !isNaN(y2)) {
                        box.style.left = (rightX - width) + 'px';
                        box.style.top = Math.min(y1, y2) + 'px';
                        box.style.width = width + 'px';
                        box.style.height = Math.abs(y2 - y1) + 'px';
                        box.style.display = 'block';
                    }
                });
            } catch (e) {
                log('âŒ æ›´æ–° VP ä½ç½®å¤±è´¥: ' + e.message, 'error');
            }
        }
        
        // æµ‹è¯• Order Blocks
        function testOrderBlocks() {
            log('ğŸ”§ å¼€å§‹æµ‹è¯• Pivot Order Blocks...', 'info');
            
            // æ¸…é™¤æ—§çš„
            obElements.forEach(el => el.remove());
            obElements = [];
            
            // åˆ›å»º2ä¸ªè®¢å•å—
            const blocks = [
                { type: 'support', priceHigh: 98, priceLow: 96, startTime: '2024-01-20', endTime: '2024-03-31' },
                { type: 'resistance', priceHigh: 104, priceLow: 102, startTime: '2024-02-01', endTime: '2024-03-31' }
            ];
            
            blocks.forEach(block => {
                const box = document.createElement('div');
                box.className = 'order-block';
                box.style.position = 'absolute';
                box.style.pointerEvents = 'none';
                box.style.zIndex = '10';
                box.style.border = '2px solid';
                box.style.borderRadius = '4px';
                
                if (block.type === 'support') {
                    box.style.backgroundColor = 'rgba(0, 255, 0, 0.15)';
                    box.style.borderColor = 'rgba(0, 255, 0, 0.6)';
                } else {
                    box.style.backgroundColor = 'rgba(255, 0, 0, 0.15)';
                    box.style.borderColor = 'rgba(255, 0, 0, 0.6)';
                }
                
                box.dataset.type = block.type;
                box.dataset.priceHigh = block.priceHigh;
                box.dataset.priceLow = block.priceLow;
                box.dataset.startTime = block.startTime;
                box.dataset.endTime = block.endTime;
                
                chartContainer.appendChild(box);
                obElements.push(box);
            });
            
            log('âœ… åˆ›å»ºäº† ' + blocks.length + ' ä¸ª Order Blocks', 'success');
            
            // æ›´æ–°ä½ç½®
            updateOBPositions();
            
            // ç›‘å¬å›¾è¡¨å˜åŒ–
            chart.timeScale().subscribeVisibleLogicalRangeChange(updateOBPositions);
        }
        
        function updateOBPositions() {
            try {
                const timeScale = chart.timeScale();
                const chartHeight = chartContainer.clientHeight;
                const priceRange = chart.priceScale('right').getVisiblePriceRange();
                
                if (!priceRange) return;
                
                const priceMin = priceRange.from;
                const priceMax = priceRange.to;
                const priceSpan = priceMax - priceMin;
                
                obElements.forEach(box => {
                    const priceHigh = parseFloat(box.dataset.priceHigh);
                    const priceLow = parseFloat(box.dataset.priceLow);
                    const startTime = box.dataset.startTime;
                    const endTime = box.dataset.endTime;
                    
                    const x1 = timeScale.timeToCoordinate(startTime);
                    const x2 = timeScale.timeToCoordinate(endTime);
                    const y1 = chartHeight * (1 - (priceHigh - priceMin) / priceSpan);
                    const y2 = chartHeight * (1 - (priceLow - priceMin) / priceSpan);
                    
                    if (x1 !== null && x2 !== null && !isNaN(y1) && !isNaN(y2)) {
                        box.style.left = Math.min(x1, x2) + 'px';
                        box.style.top = Math.min(y1, y2) + 'px';
                        box.style.width = Math.abs(x2 - x1) + 'px';
                        box.style.height = Math.abs(y2 - y1) + 'px';
                        box.style.display = 'block';
                    }
                });
            } catch (e) {
                log('âŒ æ›´æ–° OB ä½ç½®å¤±è´¥: ' + e.message, 'error');
            }
        }
        
        // æµ‹è¯• EMA
        function testEMA() {
            log('ğŸ”§ å¼€å§‹æµ‹è¯• EMA çº¿æ¡...', 'info');
            
            // æ¸…é™¤æ—§çš„
            emaSeriesList.forEach(series => chart.removeSeries(series));
            emaSeriesList = [];
            
            // è®¡ç®—ç®€å•çš„EMAï¼ˆè¿™é‡Œç”¨SMAä»£æ›¿ï¼‰
            const ema12Data = [];
            const ema18Data = [];
            const period12 = 12;
            const period18 = 18;
            
            for (let i = 0; i < testData.length; i++) {
                if (i >= period12 - 1) {
                    let sum = 0;
                    for (let j = 0; j < period12; j++) {
                        sum += testData[i - j].close;
                    }
                    ema12Data.push({ time: testData[i].time, value: sum / period12 });
                }
                
                if (i >= period18 - 1) {
                    let sum = 0;
                    for (let j = 0; j < period18; j++) {
                        sum += testData[i - j].close;
                    }
                    ema18Data.push({ time: testData[i].time, value: sum / period18 });
                }
            }
            
            // æ·»åŠ  EMA12
            const ema12Series = chart.addLineSeries({
                color: '#FFD700',
                lineWidth: 2,
                title: 'EMA12',
                priceLineVisible: false,
                lastValueVisible: false,
            });
            ema12Series.setData(ema12Data);
            emaSeriesList.push(ema12Series);
            
            // æ·»åŠ  EMA18
            const ema18Series = chart.addLineSeries({
                color: '#2962FF',
                lineWidth: 2,
                title: 'EMA18',
                priceLineVisible: false,
                lastValueVisible: false,
            });
            ema18Series.setData(ema18Data);
            emaSeriesList.push(ema18Series);
            
            log('âœ… æ·»åŠ äº† 2 æ¡ EMA çº¿', 'success');
        }
        
        function clearAll() {
            log('ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æŒ‡æ ‡...', 'info');
            
            vpElements.forEach(el => el.remove());
            vpElements = [];
            
            obElements.forEach(el => el.remove());
            obElements = [];
            
            emaSeriesList.forEach(series => chart.removeSeries(series));
            emaSeriesList = [];
            
            log('âœ… å·²æ¸…é™¤æ‰€æœ‰æŒ‡æ ‡', 'success');
        }
        
        // è‡ªåŠ¨æµ‹è¯•
        log('ğŸ“ ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æµ‹è¯•å„ä¸ªæŒ‡æ ‡', 'info');
    </script>
</body>
</html>
